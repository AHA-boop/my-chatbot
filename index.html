<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Sheets + GPT Chatbot</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter 폰트 -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 스크롤바 스타일링 */
        .chat-container::-webkit-scrollbar {
            width: 8px;
        }
        .chat-container::-webkit-scrollbar-track {
            background: #f1f5f9;
        }
        .chat-container::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 4px;
        }
        .chat-container::-webkit-scrollbar-thumb:hover {
            background-color: #94a3b8;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">
    <div class="relative bg-white w-full max-w-2xl h-[80vh] rounded-2xl shadow-xl flex flex-col overflow-hidden">
        <!-- 헤더 -->
        <div class="p-4 bg-blue-600 text-white text-center font-bold text-xl rounded-t-2xl">
            Google Sheets 기반 챗봇
        </div>

        <!-- 채팅 메시지 컨테이너 -->
        <div id="chat-container" class="flex-1 p-6 overflow-y-auto space-y-4 chat-container">
            <!-- 메시지는 여기에 동적으로 추가됩니다 -->
        </div>

        <!-- 로딩 인디케이터 -->
        <div id="loading-indicator" class="flex items-center justify-center p-4 border-t border-gray-200 hidden">
            <span class="animate-bounce mr-2 text-3xl text-gray-400">...</span>
            <span class="text-gray-500 italic">챗봇이 생각 중입니다...</span>
        </div>

        <!-- 입력 필드 및 버튼 -->
        <div class="p-4 bg-white border-t border-gray-200 flex items-center rounded-b-2xl">
            <input type="text" id="user-input" placeholder="메시지를 입력하세요..."
                   class="flex-1 p-3 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all">
            <button id="send-button"
                    class="ml-3 px-6 py-3 bg-blue-600 text-white rounded-full font-semibold shadow-md hover:bg-blue-700 transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed">
                전송
            </button>
        </div>
    </div>

    <!-- 모달 메시지 박스 (alert() 대신 사용) -->
    <div id="message-modal" class="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50 hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h3 class="text-xl font-bold mb-4" id="modal-title">알림</h3>
            <p id="modal-message" class="text-gray-700 mb-6"></p>
            <div class="flex justify-end">
                <button id="close-modal" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600">확인</button>
            </div>
        </div>
    </div>

    <script>
        //
        // Google Sheets 기반 챗봇을 위한 프런트엔드 JavaScript 코드입니다.
        // 이 스크립트는 UI 상호작용을 처리하고 Google Apps Script에 메시지를 보냅니다.
        //

        // === 설정 ===
        // 여기에 배포한 Apps Script의 웹 앱 URL을 붙여넣으세요.
        const SCRIPT_URL = 'YOUR_DEPLOYED_APPS_SCRIPT_URL';
        
        // 사용자를 구분하기 위한 고유 ID를 생성하거나 가져옵니다.
        // 여기서는 임시로 로컬 스토리지에 저장합니다.
        let userId = localStorage.getItem('chatbot-user-id');
        if (!userId) {
            userId = crypto.randomUUID();
            localStorage.setItem('chatbot-user-id', userId);
        }

        // === DOM 요소 가져오기 ===
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const loadingIndicator = document.getElementById('loading-indicator');
        const messageModal = document.getElementById('message-modal');
        const modalMessage = document.getElementById('modal-message');
        const closeModalButton = document.getElementById('close-modal');

        // === 이벤트 리스너 ===
        sendButton.addEventListener('click', sendMessage);
        userInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                sendMessage();
            }
        });
        closeModalButton.addEventListener('click', () => messageModal.classList.add('hidden'));

        /**
         * 사용자 메시지를 전송하고 응답을 받는 주 함수입니다.
         * Exponential Backoff를 사용하여 API 호출을 재시도합니다.
         */
        async function sendMessage() {
            const message = userInput.value.trim();
            if (message === '') return;

            // UI를 업데이트하고 사용자 메시지를 표시합니다.
            appendMessage(message, 'user');
            userInput.value = '';
            
            // 전송 버튼과 입력 필드를 비활성화하고 로딩 인디케이터를 표시합니다.
            toggleUI(false);

            let retries = 0;
            const maxRetries = 5;
            let success = false;

            while (retries < maxRetries && !success) {
                try {
                    const payload = {
                        message: message,
                        userId: userId,
                    };

                    const response = await fetch(SCRIPT_URL, {"https://script.google.com/macros/s/AKfycbwn_tIe8QXfljrVZRV_FlRnYhx5lIGCJLRvg-z5FaEvUNWLREOmZUa-IlL9YwNH357z/exec"
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(payload),
                    });

                    if (!response.ok) {
                        const errorText = await response.text();
                        console.error(`HTTP 오류! 상태: ${response.status}, 응답: ${errorText}`);
                        throw new Error(`네트워크 응답이 올바르지 않습니다: ${response.status}`);
                    }

                    const result = await response.json();

                    if (result.error) {
                        throw new Error(result.error);
                    }

                    appendMessage(result.response, 'bot');
                    success = true; // 성공 시 루프 종료
                } catch (error) {
                    console.error('API 호출 중 오류 발생:', error);
                    retries++;
                    if (retries < maxRetries) {
                        const delay = Math.pow(2, retries) * 1000;
                        console.log(`${delay / 1000}초 후에 재시도합니다... (재시도 횟수: ${retries})`);
                        await new Promise(res => setTimeout(res, delay));
                    } else {
                        // 최대 재시도 횟수를 초과하면 오류를 표시합니다.
                        showCustomAlert('챗봇 응답 오류', `메시지를 보낼 수 없습니다. 오류: ${error.message}`);
                        appendMessage('죄송합니다. 현재 챗봇에 문제가 발생했습니다.', 'bot');
                    }
                }
            }

            // UI를 다시 활성화합니다.
            toggleUI(true);
        }

        /**
         * 채팅 컨테이너에 메시지를 추가합니다.
         * @param {string} message - 표시할 메시지 텍스트
         * @param {string} sender - 'user' 또는 'bot'
         */
        function appendMessage(message, sender) {
            const messageWrapper = document.createElement('div');
            messageWrapper.classList.add('flex', sender === 'user' ? 'justify-end' : 'justify-start');

            const messageBubble = document.createElement('div');
            messageBubble.classList.add(
                'rounded-xl',
                'p-3',
                'max-w-xs',
                'break-words',
                sender === 'user' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-800'
            );
            messageBubble.innerText = message;
            
            messageWrapper.appendChild(messageBubble);
            chatContainer.appendChild(messageWrapper);
            chatContainer.scrollTop = chatContainer.scrollHeight; // 스크롤을 맨 아래로 이동
        }

        /**
         * 로딩 상태에 따라 UI 요소를 토글합니다.
         * @param {boolean} isEnabled - UI 활성화 여부
         */
        function toggleUI(isEnabled) {
            userInput.disabled = !isEnabled;
            sendButton.disabled = !isEnabled;
            loadingIndicator.classList.toggle('hidden', isEnabled);
        }

        /**
         * alert() 대신 사용할 사용자 지정 모달을 표시합니다.
         * @param {string} title - 모달 제목
         * @param {string} message - 모달에 표시할 메시지
         */
        function showCustomAlert(title, message) {
            document.getElementById('modal-title').innerText = title;
            modalMessage.innerText = message;
            messageModal.classList.remove('hidden');
        }
    </script>
</body>
</html>
